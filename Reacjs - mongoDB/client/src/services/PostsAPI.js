import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
import { API_URL } from "../config";

import { selectCurrenToken } from "../slices/auth.slice";

// Define a service using a base URL and expected endpoints
export const PostsAPI = createApi({
    reducerPath: "postManagement",
    // Tag types are used for caching and invalidation.
    tagTypes: ["PostsList"],
    baseQuery: fetchBaseQuery({
        baseUrl: API_URL,
        prepareHeaders: (headers, { getState }) => {
            const token = selectCurrenToken(getState()); // Retrieve token from Redux state using selectToken selector
            if (token) {
                headers.append("Authorization", `${token}`);
            }
            headers.append("Content-Type", "application/json");
            return headers;
        },
    }),

    endpoints: (builder) => ({
        // Supply generics for the return type (in this case `FlowerApiResponse`)
        // and the expected query argument. If there is no argument, use `void`
        // for the argument type instead.
        getPosts: builder.query({
            query: () => `posts`,
            // `providesTags` determines which 'tag' is attached to the
            // cached data returned by the query.
            providesTags: (result, _error, _arg) =>
                result
                    ? [
                        ...result.map(({ id }) => ({ type: "postManagement", id })),
                        { type: "PostsList", id: "LIST" },
                    ]
                    : [{ type: "PostsList", id: "LIST" }],
        }),
        addPosts: builder.mutation({
            query: (body) => {
                console.log(body)
                // covert Data
                return {
                    method: "POST",
                    url: `posts`,
                    body: body,
                };
            },
            invalidatesTags: [{ type: "PostsList", id: "LIST" }],
        }),
        //     editUser: builder.mutation({
        //         query: (payload) => {
        //             //   const newBody = {
        //             //     fullname: payload.body.name,
        //             //     email: payload.body.email,
        //             //     phone_number: payload.body.phone,
        //             //     date_of_birth: payload.body.DOB,
        //             //     gender: payload.body.gender,
        //             //     active: payload.body.Status,
        //             //     role_id: RoleConstant[payload.body.UserType],
        //             //   };
        //             //   console.log(newBody);
        //             return {
        //                 method: "PUT",
        //                 url: `users/` + payload.id,
        //                 body: payload.body,
        //             };
        //         },
        //         invalidatesTags: (res, err, arg) => [{ type: "PostsList", id: arg.id }],
        //     }),
        getPostById: builder.query({
            query: (id) => `posts/${id}` ,
            providesTags: (result, error, id) => [{ type: "PostsList", id }], // Tag cho cache
        }),
        //     // getClassProgramById: builder.query({
        //     //   query: (id) => `training-program/get-training-program/${id}`,
        //     //   providesTags: (result, error, id) => [{ type: "ProgramList", id }],
        //     // }),
        //     // getAllSyllabusByIdTrainig: builder.query({
        //     //   query: (id) => `get_all_syllabuses/${id}`,
        //     //   providesTags: (result, error, id) => [{ type: "SyllabusList", id }],
        //     // }),
    }),
});

// Export hooks for usage in functional components, which are
// auto-generated based on the defined endpoints
// Hooks are auto-generated by RTK-Query
export const {
    useAddPostsMutation,
    useGetPostsQuery,
    useGetPostByIdQuery
    // useEditUserMutation,
    // useGetUserByIdQuery
} = PostsAPI;
